<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[generators]]></title>
    <url>%2F2018%2F05%2F02%2Fgenerators%2F</url>
    <content type="text"><![CDATA[接續上一篇的 iterator，來看看 generators 到底是什麼？ Generator function (function*)123function* name([param[, param[, ... param]]]) &#123; statements&#125; 一個 generator 函示，使用 function* 作為宣告，會回傳一個 Generator 物件。 generator 可以被中斷跳出，等到再次呼叫的時候再繼續執行。 呼叫 function* 並不會立刻執行函式內容，而是會回傳一個 iterator 物件。當執行 iterator 的 next 方法的時候，function* 裡面的 code 才會被執行，並停在第一個 yield expression 前。呼叫 next 並執行，會回傳一個物件，該物件會帶有一個 value 屬性，其值就是 yield 回傳的值，還會帶有一個 done 屬性，他的型態是 boolean。({value: val, done: true/false})。當該 yield expression 是最後一個的時候，done 屬性會是 true。 generator 裡面的 yield expeession 不一定就直接回傳一個值。也可以再指向另一個 generator function。如下：12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i) &#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 generators 也可以帶入參數。如下面的範例： 123456789101112131415function* logGenerator() &#123; console.log(0); console.log(1, yield); console.log(2, yield); console.log(3, yield);&#125;var gen = logGenerator();// the first call of next executes from the start of the function// until the first yield statementgen.next(); // 0gen.next('pretzel'); // 1 pretzelgen.next('california'); // 2 californiagen.next('mayonnaise'); // 3 mayonnaise 當 function* 裡面有 return，在執行到該行的時候該 function* 就會結束。即使後面還有其他的 yield expression，呼叫 next 也不會再繼續執行。當 generator 執行完，會回傳 {value: undefined, done: true}。 Generators 不能作為建構函式 以下內容整理自這段影片 Generators in JavaScript 用 generator 來改寫 iterator利用 generator 來改寫上一篇的範例中的 iterator。 123456789101112131415161718192021222324252627const dragonArmy = &#123; [Symbol.iterator] : function*()&#123; while(true)&#123; const enoughDragonSpawned = Math.random() &gt; 0.75; if( enoughDrangonSpawned ) return yield makeDragon() &#125; &#125; // 上一篇 iterator 的寫法 // [Symbol.iterator]: () =&gt; &#123; // return &#123; // next: () =&gt; &#123; // const enoughDragonSpawned = Math.random() &gt; 0.75; // if(!enoughDragonSpawned) // return &#123; // value: makeDragon(), // done: false // &#125; // return &#123;done: true&#125; // &#125; // &#125; // &#125;&#125;for (const dragon of dragonArmy)&#123; dragon // &#125; generator 範例宣告一個 someDragon 的 generator 函式來觀察 generator 的執行。123456789101112131415funtion* someDragon()&#123; while(true)&#123; // it's always true const enoughDragonSpawned = Math.random() &gt; 0.75; if( enoughDrangonSpawned ) return yield makeDragon() &#125;&#125;const iterator = someDragons();iterator.next() // &#123; value: 'medium lightning dragon', done: false &#125;iterator.next() // &#123; value: 'tiny lightning dragon', done: false &#125;iterator.next() // &#123; value: 'big fire dragon', done: false &#125;iterator.next() // &#123; value: 'undefined', done: true &#125;iterator.next() // &#123; value: 'undefined', done: true &#125;iterator.next() // &#123; value: 'undefined', done: true &#125; 123456789101112131415funtion* someDragon()&#123; yield 'fluffinkins some dragon'; yield 'make the fine dragon'; if(Math.random() &gt; 0.5) return; // 當它 return的時候 done: true，後面的程式碼都不會被執行。 yield 'hardy the dog'; return 'hardy the dog!!' // 使用 return the next iteration will not happen&#125;const iterator = someDragons();iterator.next() // &#123; value: 'medium lightning dragon', done: false &#125;iterator.next() // &#123; value: 'tiny lightning dragon', done: false &#125;iterator.next() // &#123; value: 'big fire dragon', done: false &#125;iterator.next() // &#123; value: 'undefined', done: true &#125;iterator.next() // &#123; value: 'undefined', done: true &#125;iterator.next() // &#123; value: 'undefined', done: true &#125; 再重複一次 Calling a generator function does NOT run it …yet! iterators 跟 generator 的關係，可以想成電視和遙控器的關係。iterators 就像是遙控器，透過 next() 來操縱 generator 的執行。 影片的總結說到， It’s just a SYNTX SUGAR to help create iterator.generator 就是一個語法糖，可以更容易的建立 iterator。 不使用 generator 來重寫 someDragon 函式透過下面的重寫，可以更清楚看出來整個流程，也可以比較出為什麼主持人會說 generator 是語法糖。123456789101112131415161718192021222324function someDragons()&#123; let iterations = -1; const iterator = &#123; next: () =&gt; &#123; iterations ++ if(iterations === 0) return &#123; value: 'fluffykins dragon', done: false &#125;; if(iterations === 1) return &#123; value: 'mark the fine dragon', done: false &#125;; if(iterations === 2)&#123; if (Math.random &gt; 0.5)&#123; return &#123;value: 'hardy the dog', done: true&#125; &#125; &#125; return &#123;done: true&#125;; &#125; &#125; return iterator&#125;const iterator = someDragons();console.log(iterator.next()) // &#123;value: 'fluffykins dragon', done: false &#125;console.log(iterator.next()) // &#123;value: 'mark the fine dragon', done: false &#125;console.log(iterator.next()) // &#123; done: false &#125; 小結本篇主要是延續上一篇有關 iterators 來介紹 generators，至於有關 async 是怎麼建立在 generators 上，async, await f又是怎麼一回事就等之後再來繼續研究。 參考資料 Generators in JavaScript function* MDN]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterators]]></title>
    <url>%2F2018%2F04%2F23%2Fiterator%2F</url>
    <content type="text"><![CDATA[以下內容整理自這段影片 Iterators in JavaScript using Quokka 什麼是 iterators ?為什麼 for…of 可以對 Array 做迭代 ? Array 提供了 iterators 給 for...of loop，讓 for...of loop 利用 iterators 進行迭代。 那 for…of 又是怎麼得到 iterators ? 要解釋這個，要先岔開說一下 Symbol。Symbol 是什麼？ 影片中解釋它可以看作是一個 unique key。至於詳細的 Symbol.iterator 說明可以參考 MDN Symbol。下面例子裡面的變數 iterator 會回傳一個物件，並且帶有 next 屬性可以執行。這和 generator* 有關，之後會再發一篇有關 generator 說明。就是因為 iterator 的這個特性，所以和 forEach 不同， for...of 可以對除了 Array 以外的東西進行迭代，String 也可以。只要進行迭代的對象具有 iterator 屬性就可以。 用以下的例子來做說明：12345678910111213141516171819const dragons = [ 'cool dragon', 'angry dragon', 'nasty dragon']Symbol.iterator // Symbol&#123;&#125;const iterator = dragons[Symbol.iterator]()iterator // &#123;[Iterator]&#125;// 下面這段就是 for...of loop 在執行的iterator.next() // 會得到物件：&#123;value: 'cool dragon', done: false&#125;iterator.next() // 會得到物件：&#123;value: 'angry dragon', done: false&#125;iterator.next() // 會得到物件：&#123;value: 'nasty dragon', done: false&#125;iterator.next() // 會得到物件：&#123;value: 'undefined', done: true&#125;for(const dragon of dragons)&#123;&#125; 1234567891011121314151617181920// 引入 randomNumberconst randomNumber = require('random-number');function randomItem(array)&#123; const randomIndex = randomNumber(&#123; min: 0, max: array.length - 1, integer: true &#125;); return array[randomIndex];&#125;const makeDragon = () =&gt; &#123; const dragonSizes = ['big', 'medium', 'tiny']; const dragonAbilities = ['fire', 'ice', 'lightning']; return randomItem(dragonSizes) + ' ' + randomItem(dranAbilities) + ' ' + 'dragon;&#125;makeDragon() // tiny fire dragon 隨機出現不同組合的 dragon 下面這個例子就是直接自己寫一個 for…of 的效果 Symbol.iterator 會回傳一個 object，裡面有 next 屬性。 和上面的例子做對照，可以看得比較清楚 iterator 到底是怎麼操作執行的。 真正的 iterator 不會設定一個隨機變數去控制執行的次數。這裡只是說明可以自己設定 iterator 執行的條件。12345678910111213141516171819const dragonArmy = &#123; [Symbol.iterator]: () =&gt; &#123; return &#123; next: () =&gt; &#123; const enoughDragonSpawned = Math.random() &gt; 0.75; if(!enoughDragonSpawned) return &#123; value: makeDragon(), done: false &#125; return &#123;done: true&#125; &#125; &#125; &#125;&#125;for (const dragon of dragonArmy)&#123; dragon // &#125; 小結 可以自己建立想要的 iterators 進行迭代。 iterators 也可以是 Asynchronous。 generator 之後會再另外提到，它是一個建立 iterators 的語法糖。 參考資料Iterators in JavaScript using Quokka很喜歡這個 Youtube 頻道，推薦大家沒事可以看看。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Destructuring 的用法]]></title>
    <url>%2F2018%2F04%2F19%2Fdestructuring%2F</url>
    <content type="text"><![CDATA[在弄清楚它是什麼之前，不知道它到底可以幹嘛用。弄清楚之後才恍然大悟，原來它真的蠻好用！ 基礎用法123456789101112131415161718var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); //&#123;c: 30, d: 40&#125; 解構賦值可以用在 array 和 object 上。也可以混著使用，後面會說到。透過解構賦值可以簡單的宣告變數，不用再一個一個的去宣告。 陣列的解構賦值 可以賦予預設值。 可以對調變數值。 忽略部分的值 使用 , 和空白做分隔，就可以忽略不需要的值。 1234567function f() &#123; return [1, 2, 3];&#125;var [a, , b] = f();console.log(a); // 1console.log(b); // 3 Rest 的使用 使用 ... 可以擷取剩下的值。 要特別注意，它只能使用在最後一個變數。 123var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2, 3] 如果 rest 不是最後一個變數，會跳錯誤。12var [a, ...b,] = [1, 2, 3];// SyntaxError: rest element may not have a trailing comma 物件的解購賦值 基本上和陣列的解構賦值是相同的。 可以重新命名變數名稱，也可以給予變數預設值。 需要注意，object destructuring 若是在事先宣告的情況下，需要有 ( ) 將它包覆起來。 12var a, b;(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;); 物件的 rest 用法 1234let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;a; // 10 b; // 20 rest; // &#123; c: 30, d: 40 &#125; 巢狀的物件和陣列解構 （Nested object and array destructuring）With Object1234567891011121314function makeItem()&#123; return &#123; data: &#123; item: &#123; name: 'Shoes', size: &#123; US: 10, EU: 44 &#125; &#125; &#125;, status: 'live'; &#125;&#125; 123456789const res = makeItem()const &#123;data, status&#125; = res; console.log(data, status); // data 會是 item 物件; status: 'live'// data 這個變數是不存在的，它只是用來取得 item 的路徑const &#123;data: &#123;item&#125;&#125; = res; // 可以繼續解構下去。同時也可以更改變數名稱const &#123;data: &#123;item: &#123;name, size:&#123; US: weird, EU: normal&#125;&#125;&#125;&#125; = res; With Array &amp; Object 陣列和物件的解構賦值可以混合使用。 1234567891011function makeArryItems()&#123; return &#123; data: &#123; items: [ &#123;name: 'Shoes', price: 100&#125;, &#123;name: 'Size', price: 250&#125; ] &#125;, status: 'live' &#125;&#125; 1234const res = makeArryItems();const &#123;data:&#123;items: [item1, item2]&#125;&#125; = res;const &#123;data:&#123;items: [&#123;name:name1, price:price1&#125;,&#123;name:name2, price:price2&#125;]&#125;&#125; = res; 在迭代使用解構賦值 (For of iteration and destructuring)123456789101112131415161718192021222324252627var people = [ &#123; name: 'Mike Smith', family: &#123; mother: 'Jane Smith', father: 'Harry Smith', sister: 'Samantha Smith' &#125;, age: 35 &#125;, &#123; name: 'Tom Jones', family: &#123; mother: 'Norah Jones', father: 'Richard Jones', brother: 'Howard Jones' &#125;, age: 25 &#125;];for (var &#123;name: n, family: &#123;father: f&#125;&#125; of people) &#123; console.log('Name: ' + n + ', Father: ' + f);&#125;// "Name: Mike Smith, Father: Harry Smith"// "Name: Tom Jones, Father: Richard Jones" 在 function parameter 中使用12345678910111213141516171819function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName, fullName: &#123;firstName: name&#125;&#125;) &#123; console.log(displayName + ' is ' + name);&#125;var user = &#123; id: 42, displayName: 'jdoe', fullName: &#123; firstName: 'John', lastName: 'Doe' &#125;&#125;;console.log('userId: ' + userId(user)); // "userId: 42"whois(user); // "jdoe is John" 參考資料destructuring MDNNested Object Destructuring works]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window 物件和 Element 相關定位]]></title>
    <url>%2F2018%2F04%2F15%2Fwindow-obj%2F</url>
    <content type="text"><![CDATA[部分 window 物件屬性，及 Element 的 position 相關屬性整理。 window 物件 特性 說明 window.innerHeight 視窗的高度 (不包括 chrome 瀏覽器/ 使用者操作介面部分 ) window.innerWidth 視窗的寬度 (不包括 chrome 瀏覽器/ 使用者操作介面部分 ) window.outerHeight 視窗的高度 (包括 chrome 瀏覽器/ 使用者操作介面部分 ) window.innerWidth 視窗的寬度 (包括 chrome 瀏覽器/ 使用者操作介面部分 ) window.pageXOffset 網頁文件水平捲動的距離 ( 和 window.scrollX 是一樣的，需跨瀏覽器時建議使用 pageXOffset) window.pageYOffset 網頁文件垂直捲動的距離 ( 和 window.scrollY 是一樣的，需跨瀏覽器時建議使用 pageYOffset) window.screenX 滑鼠的 X 座標，相對於螢幕的左上角 window.screenY 滑鼠的 Y 座標，相對於螢幕的左上角 window.location window 物件目前的頁面 URL (或本機路徑) window.document 參考至 document 物件，用以代表目前的頁面內容 window.history 參考至 history 物件，用以擷取瀏覽器視窗或頁籤所包含的瀏覽紀錄資訊 window.history.length history 物件中的瀏覽紀錄筆數 window.screen screen 物件 window.innerHeight vs window.outerHeight圖片來源: https://developer.mozilla.org/en-US/docs/Web/API/Window/outerHeight screen 物件 特性 說明 screen.width 使用者的螢幕寬度 screen.height 使用者的螢幕高度 screen.availWidth 使用者的螢幕寬度剪掉系統的控制列 screen.availHeight 使用者的螢幕寬度剪掉系統的控制列 screen.colorDepth the number of bits used to display one color screen.pixelDepth the pixel depth of the screen ps. For modern computers, Color Depth and Pixel Depth are equal. Element 在頁面中的位置 特性 說明 HTMLElement.offsetParent 回傳目前元件計算 offset 的祖先元件 HTMLElement.offsetTop 距離最近的祖先節點頂端的距離 HTMLElement.offsetLeft 距離最近的祖先節點左邊的距離 HTMLElement.offsetHeight 元素高度 (包括垂直 padding 和 border，若該元素有水平 scrollbar 也會算進去) HTMLElement.offsetWidth 元素寬度 (包括垂直 padding 和 border，若該元素有垂直 scrollbar 也會算進去。) Element.clientHeight 元素寬度，包括padding (不包括垂直 border 和 margin，若該元素有垂直 scrollbar 不會算進去。) Element.clientWidth 元素寬度，包括padding (不包括水平 border 和 margin，若該元素有垂直 scrollbar 不會算進去。) offsetHeight &amp; offsetWidth圖片來源: https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png clientHeight &amp; clientWidth圖片來源: https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth 參考資料 Javascript &amp; JQuery 網站互動設計程式進化之道 JavaScript Window Screen Window.outerHeight]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[foreach, for...of, and for...in]]></title>
    <url>%2F2018%2F04%2F12%2Fdifferent-for-loop%2F</url>
    <content type="text"><![CDATA[Array.forEach() 只適用於 Array (類陣列也可以) 將陣列內的每個元素，皆傳入並執行給定的函式 不像 map() 或 reduce()， forEach 最後一個值一定會回傳 undefined forEach 是不可鏈接的 123arr.forEach(function callback(currentValue[, index[, array]]) &#123; //your iterator&#125;[, thisArg]); 參數 currentValue: 代表目前被處理中的 Array 之中的那個元素。 index (optional): 代表目前被處理中的 Array 之中的那個元素的index. array (optional): 呼叫 forEach() 方法的那個 Array 本身，也就是上面語法中的 arr。 thisArg (optional): 執行 callback 回呼函式的 this（即參考之 Object）值。 thisArg 的用法範例 如果是使用箭頭函式，可以直接忽略 thisArg，因為箭頭函式會直接綁定 this。123456789101112131415function Counter() &#123; this.sum = 0; this.count = 0;&#125;Counter.prototype.add = function(array) &#123; array.forEach(function(entry) &#123; this.sum += entry; ++this.count; &#125;, this);&#125;;const obj = new Counter();obj.add([2, 5, 9]);obj.count; // 3 obj.sum; // 16 for…in for…in 迴圈只迭代 enumerable properties。 for…in 迴圈迭代物件屬性的順序是隨意的。 for…in 不應該用來迭代一個索引順序很重要的陣列。 陣列索引只是以整數命名的可列舉屬性，其他方面等同於一般物件屬性。 無法擔保 for…in 以特定順序傳回索引，並且它將傳回全部可列舉屬性，包括非整數名的，以及繼承而來的可列舉屬性。如果順序是重要的，那應該要考慮使用 forEach 或 for…of。 123for (variable in object) &#123; ...&#125; 參數 variable: A different property name is assigned to variable on each iteration.object Object: whose enumerable properties are iterated. 用法12345678910var obj = &#123;a: 1, b: 2, c: 3&#125;; for (const prop in obj) &#123; console.log(`obj.$&#123;prop&#125; = $&#123;obj[prop]&#125;`);&#125;// Output:// "obj.a = 1"// "obj.b = 2"// "obj.c = 3" for…of for…of 會 loop through 可迭代的物件(包括: String, Array, Array-like arguments, or NodeList objects, TypedArray, Map and Set, and user-defined iterables) 123for (variable of iterable) &#123; statement&#125; 參數 variable: On each iteration a value of a different property is assigned to variable. iterable: Object whose iterable properties are iterated. 用法12345678910let iterable = [10, 20, 30];// 也可以使用 const 定義變數，如果不會再改變的話。下面使用 let 是因為 value 之後還要再做轉換。for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 for…in VS for…of以下節錄自 MDN，因為無法很好的翻成中文，英文的說明也比較簡潔易懂。 Both for…in and for…of statements iterate over something. The main difference between them is in what they iterate over. The for…in statement iterates over the enumerable properties of an object, in an arbitrary order. The for…of statement iterates over data that iterable object defines to be iterated over. example12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 這個例子可以很清楚地看出兩者的不同點。一段一段拆分出來看。 12345Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;; let iterable = [3, 5, 7]; iterable.foo = 'hello'; 上面這段 code，Object 和 Array 的原型分別加進了 objCustom. arrCustom。因此，iterable 這個陣列也因為繼承和原型鏈的關係繼承了這兩個屬性。 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom" &#125; 接著，使用 for…in 對 iterable 做迭代。它並不會 log 出 3,5,7 或是 &#39;hello&#39;，因為他們都不是 enumerable 的屬性。但會 log 出陣列的索引質以及 objCustom 和 arrCustom。0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;。他們都是 enumerable 的屬性。 12345for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125; 這個迴圈和上一段的迴圈是很相像的，不過加入了一個 hasOwnProperty 條件檢查迭代的 enumerable 屬性是不是物件自有的不是繼承而來的。如果是，就 log 出來。屬性 0, 1, 2, &quot;foo&quot; 都是 iterable 自有的屬性所以會顯示。但 arrCustom, objCustom 是繼承來的，就不會被 log 出來。 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7 &#125; 這個迴圈迭代並 log 出 iterable作為一個可迭代的物件迭代後回傳的 value。其中並不包含該物件的其他屬性。 什麼是 Enumerable properties ?一直在說 enumerable properties，究竟它是什麼？enumerable 的中文是 - 可列舉的。可列舉的屬性？又是指什麼？ 根據 MDN 的解釋， Enumerable properties are those properties whose internal [[Enumerable]] flag is set to true, which is the default for properties created via simple assignment or via a property initializer. Jabascript 物件的屬性它們自己內部還有屬性，其中一個內部的屬性就是 enumerable。而該 enumerable 屬性被設為 true 的屬性，就可稱是可迭代屬性。(有點饒口)如果想知道的更精確，可以閱讀 MDN 的文件。 參考文章forEach MDNfor…in MDNfor…of MDN“foreach” vs “for of” vs “for in” in JavaScript]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 - Promise (1)]]></title>
    <url>%2F2018%2F04%2F11%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[前言Promise 是 ES6 當中用來解決 christmas callback hell 的一種非同步的處理方式。 Promise 的三種狀態 Pending: 初始狀態 Fulfill: 成功完成 Result: 失敗 Promise 的狀態都是從 pending 開始，一旦 Promise 的狀態被確定(fulfill or result)，就不會再改變。 Promise Constructor 要記得處理 error 的部分 123456789101112131415161718192021222324let myPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Good to go!'); &#125;, 1000); setTimeout(() =&gt; &#123; reject('uh oh!'); &#125;,500)&#125;);myPromise.then((res) =&gt; &#123; console.log(res); &#125;, (err) =&gt; &#123; console.log(err); // uh oh!&#125;)// 或者使用 catch 處理 errormyPromise .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) Promise.all([iterable]) 等傳入的所有 Promise都跑完，會回傳一個新的 Promise。 只要有其中一個 Promise reject 就會執行 ㄒerr。 12345678910111213141516171819let myPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Good to go!'); &#125;, 1000);&#125;);let myPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Promise 2 - the promising'); &#125;, 1500);&#125;);Promise.all([myPromise, myPromise2]) .then((data) =&gt; &#123; console.log(data); // ["Good to go!", "Promise 2 - the promising"] &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) Promise.race([iterable]) 和 Promise.all() 非常相像，不同點在於，他僅會回傳第一個完成的 Promise。(不論第一個完成的是 resolve 或 reject) 1234567Promise.race([myPromise, myPromise2]) .then((data) =&gt; &#123; console.log(data); // 'Good to go!' &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) fetch 使用 fetch 做異步請求，會回傳一個 Promise。 12345678910fetch('http://api.icndb.com/jokes/random/10') .then((res) =&gt; &#123; // res.json() 會回傳另外一個 Promise，回傳一個 json 格式的資料 res.json().then((data) =&gt; &#123; console.log(data); &#125;) &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) 小結第一次接觸到 Promise 的時候，頭上都是問號。多看了好幾篇教學文之後才終於稍微比較瞭解。接下來會再找時間了解 Promise 的其他可以使用的方法，以及研究 async 和 await 如何做到 flow control。 參考資料Let’s Learn ES6 - PromisesPromise MDN]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js path module]]></title>
    <url>%2F2018%2F04%2F03%2Fnode-path-module%2F</url>
    <content type="text"><![CDATA[前言每次使用 node.js 建置環境的時候，都會使用到 path 模組，照著教學上的使用都可以正常運行，但是都沒有真正了解它代表的意思。以至於我自己在使用 path 模組的時候常常得不到我要的結果。看看它的官方檔案，研究一下它到底是怎麼使用的。 起手式基本上，path 模組已經包含在 node.js 的模組裡，不需要另外下載。只需要在使用到的檔案 require 進來就可以。1const path = require('path'); Windows vs POSIX 系統path 模組的預設行為會因為執行 Node.js 應用的環境不同而不同。在 Windows 和 POSIX 系統下會有些許的不一樣。本篇文章主要是以 POSIX 系統為主。如果是 Windows 的使用者建議可以參考一下官方的 Path | Node.js v9.10.1 文件。 Path 可調用的方法path.basename(path[, ext]) 返回路徑中最後面的部分。 ext: optional 12345path.basename('/foo/bar/baz/asdf/quux.html');// Returns: 'quux.html'path.basename('/foo/bar/baz/asdf/quux.html', '.html');// Returns: 'quux' path.delimiter 回傳目前平台的分隔符號。 ; for Windows : for POSIX 12345console.log(process.env.PATH);// Prints: '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'process.env.PATH.split(path.delimiter);// Returns: ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin'] path.dirname(path) 返回路徑中代表資料夾的部分，相似於 Unix 的 dirname 指令。 12path.dirname('/foo/bar/baz/asdf/quux');// Returns: '/foo/bar/baz/asdf' path.extname(path) 回傳路徑最後面的部分的 . 後面的副檔名。如果 . 後面為空或沒有 .，又或者最後面部分開頭就是 .，會直接回傳空字串。 用例子來說明會比較清楚：1234567891011121314path.extname('index.html');// Returns: '.html'path.extname('index.coffee.md');// Returns: '.md'path.extname('index.');// Returns: '.'path.extname('index');// Returns: ''path.extname('.index');// Returns: '' path.format(pathObject) 回傳以該物件為根據的路徑。和 path.parse() 是完全相反的。 object 的屬性包含： dir root base name ext 設定 pathObject 屬性的時候要注意，上列的屬性間依照組合的方式會有不同的優先順序。 當 dir 和 root 屬性同時存在時， root 會被忽略。 當 base 屬性存在時， name 和 ext 會被忽略。 1234567891011121314151617181920path.format(&#123; root: '/ignored', dir: '/home/user/dir', base: 'file.txt'&#125;);// Returns: '/home/user/dir/file.txt'path.format(&#123; root: '/', base: 'file.txt', ext: 'ignored'&#125;);// Returns: '/file.txt'path.format(&#123; root: '/', name: 'file', ext: '.txt'&#125;);// Returns: '/file.txt' path.isAbsolute(path) 判斷參數 path 是否為絕對路徑 1234path.isAbsolute('/foo/bar'); // truepath.isAbsolute('/baz/..'); // truepath.isAbsolute('qux/'); // falsepath.isAbsolute('.'); // false path.join([…paths]) 用於連接路徑。將所有的 paths 參數以目前系統的 系統分隔符 連接成一個路徑。 * paths 必須是 string 否則會跳錯12path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns: '/foo/bar/baz/asdf' path.normalize(path) 將路徑格式化轉換為標準路徑，解析 . 和 ..。刪除多餘的 / 或 \。 如果其中一個 path 後面有接 ..，則該 path 會被忽略。因為它是沒有意義的。 1234path.normalize('/foo/bar//baz/asdf/quux/..');// Returns: '/foo/bar/baz/asdf'path.normalize('/foo/bar//baz/../asdf/quux');// Returns: '/foo/bar/asdf/quux' path.parse(path) 將 path 拆成一個物件裡的各個屬性。屬性種類可參考：path.format() 1234567path.parse('/home/user/dir/file.txt');// Returns:// &#123; root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125; path.relative(from, to) 此方法帶兩個參數 (from, to)，兩個參數都應該是絕對路徑。透過 path.relative 會返回第二個參數相對於第一個參數的相對路徑。 如果兩個參數是一樣的，則會返回一個空字串。 如果其中一個參數為空字串，則執行的檔案目前的路徑則會取代該參數。 12path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// Returns: '../../impl/bbb' path.resolve([…paths]) 解析傳入的 ‘路徑’ 以及 ‘部分路徑’，組合並轉換成一個絕對路徑。 傳入的路徑參數會由右到左被執行。左邊的參數會被叫到右邊的參數前，直到組成一個絕對路徑。 如果所有的參數都已經被執行完，但還是無法產生一個絕對路徑，那就會使用目前的路徑。 最後的絕對路徑會經過格式化成正式的路徑，並且刪除多餘的 / 或 \，除非最後解析出來的路徑是根目錄。 若傳入的參數為空字串，會被忽略。 如果沒有傳入任何參數，會回傳目前的路徑。 123456789path.resolve('/foo/bar', './baz');// Returns: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// Returns: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// if the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif' 其實這樣講還是有點複雜，可以使用下面的方式來思考會比較簡單： 12path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')// Return '/tmp/subfile' $ cd foo/bar $ cd /tmp/file/ $ cd .. $ cd a/../subfile path.spe 會回傳你目前系統中預設的分隔符號。 參考資料 Path | Node.js v9.10.1 Path 模組 NodeJS - Path Tools - 這個 youtube 影片對 path 模組介紹的非常清楚]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
