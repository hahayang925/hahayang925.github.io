<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6 - Promise (1)]]></title>
    <url>%2F2018%2F04%2F11%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[前言Promise 是 ES6 當中用來解決 christmas callback hell 的一種非同步的處理方式。 Promise 的三種狀態 Pending: 初始狀態 Fulfill: 成功完成 Result: 失敗 Promise 的狀態都是從 pending 開始，一旦 Promise 的狀態被確定(fulfill or result)，就不會再改變。 Promise Constructor 要記得處理 error 的部分 123456789101112131415161718192021222324let myPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Good to go!'); &#125;, 1000); setTimeout(() =&gt; &#123; reject('uh oh!'); &#125;,500)&#125;);myPromise.then((res) =&gt; &#123; console.log(res); &#125;, (err) =&gt; &#123; console.log(err); // uh oh!&#125;)// 或者使用 catch 處理 errormyPromise .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) Promise.all([iterable]) 等傳入的所有 Promise都跑完，會回傳一個新的 Promise。 只要有其中一個 Promise reject 就會執行 ㄒerr。 12345678910111213141516171819let myPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Good to go!'); &#125;, 1000);&#125;);let myPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('Promise 2 - the promising'); &#125;, 1500);&#125;);Promise.all([myPromise, myPromise2]) .then((data) =&gt; &#123; console.log(data); // ["Good to go!", "Promise 2 - the promising"] &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) Promise.race([iterable]) 和 Promise.all() 非常相像，不同點在於，他僅會回傳第一個完成的 Promise。(不論第一個完成的是 resolve 或 reject) 1234567Promise.race([myPromise, myPromise2]) .then((data) =&gt; &#123; console.log(data); // 'Good to go!' &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) fetch  使用 fetch 做異步請求，會回傳一個 Promise。 12345678910fetch('http://api.icndb.com/jokes/random/10') .then((res) =&gt; &#123; // res.json() 會回傳另外一個 Promise，回傳一個 json 格式的資料 res.json().then((data) =&gt; &#123; console.log(data); &#125;) &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;) 小結第一次接觸到 Promise 的時候，頭上都是問號。多看了好幾篇教學文之後才終於稍微比較瞭解。接下來會再找時間了解 Promise 的其他可以使用的方法，以及研究 async 和 await 如何做到 flow control。 參考資料Let’s Learn ES6 - PromisesPromise MDN]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js path module]]></title>
    <url>%2F2018%2F04%2F03%2Fnode-path-module%2F</url>
    <content type="text"><![CDATA[前言每次使用 node.js 建置環境的時候，都會使用到 path 模組，照著教學上的使用都可以正常運行，但是都沒有真正了解它代表的意思。以至於我自己在使用 path 模組的時候常常得不到我要的結果。看看它的官方檔案，研究一下它到底是怎麼使用的。 起手式基本上，path 模組已經包含在 node.js 的模組裡，不需要另外下載。只需要在使用到的檔案 require 進來就可以。1const path = require('path'); Windows vs POSIX 系統path 模組的預設行為會因為執行 Node.js 應用的環境不同而不同。在 Windows 和 POSIX 系統下會有些許的不一樣。本篇文章主要是以 POSIX 系統為主。如果是 Windows 的使用者建議可以參考一下官方的 Path | Node.js v9.10.1 文件。 Path 可調用的方法path.basename(path[, ext]) 返回路徑中最後面的部分。 ext: optional 12345path.basename('/foo/bar/baz/asdf/quux.html');// Returns: 'quux.html'path.basename('/foo/bar/baz/asdf/quux.html', '.html');// Returns: 'quux' path.delimiter 回傳目前平台的分隔符號。 ; for Windows : for POSIX 12345console.log(process.env.PATH);// Prints: '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'process.env.PATH.split(path.delimiter);// Returns: ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin'] path.dirname(path) 返回路徑中代表資料夾的部分，相似於 Unix 的 dirname 指令。 12path.dirname('/foo/bar/baz/asdf/quux');// Returns: '/foo/bar/baz/asdf' path.extname(path) 回傳路徑最後面的部分的 . 後面的副檔名。如果 . 後面為空或沒有 .，又或者最後面部分開頭就是 .，會直接回傳空字串。 用例子來說明會比較清楚：1234567891011121314path.extname('index.html');// Returns: '.html'path.extname('index.coffee.md');// Returns: '.md'path.extname('index.');// Returns: '.'path.extname('index');// Returns: ''path.extname('.index');// Returns: '' path.format(pathObject) 回傳以該物件為根據的路徑。和 path.parse() 是完全相反的。 object 的屬性包含： dir root base name ext 設定 pathObject 屬性的時候要注意，上列的屬性間依照組合的方式會有不同的優先順序。 當 dir 和 root 屬性同時存在時， root 會被忽略。 當 base 屬性存在時， name 和 ext 會被忽略。 1234567891011121314151617181920path.format(&#123; root: '/ignored', dir: '/home/user/dir', base: 'file.txt'&#125;);// Returns: '/home/user/dir/file.txt'path.format(&#123; root: '/', base: 'file.txt', ext: 'ignored'&#125;);// Returns: '/file.txt'path.format(&#123; root: '/', name: 'file', ext: '.txt'&#125;);// Returns: '/file.txt' path.isAbsolute(path) 判斷參數 path 是否為絕對路徑 1234path.isAbsolute('/foo/bar'); // truepath.isAbsolute('/baz/..'); // truepath.isAbsolute('qux/'); // falsepath.isAbsolute('.'); // false path.join([…paths]) 用於連接路徑。將所有的 paths 參數以目前系統的系統分隔符連接成一個路徑。 * paths必須是 string 否則會跳錯12path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// Returns: '/foo/bar/baz/asdf' path.normalize(path) 將路徑格式化轉換為標準路徑，解析 . 和 ..。刪除多餘的 / 或 \。 如果其中一個 path 後面有接 ..，則該 path 會被忽略。因為它是沒有意義的。 1234path.normalize('/foo/bar//baz/asdf/quux/..');// Returns: '/foo/bar/baz/asdf'path.normalize('/foo/bar//baz/../asdf/quux');// Returns: '/foo/bar/asdf/quux' path.parse(path) 將 path 拆成一個物件裡的各個屬性。屬性種類可參考：path.format() 1234567path.parse('/home/user/dir/file.txt');// Returns:// &#123; root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' &#125; path.relative(from, to) 此方法帶兩個參數 (from, to)，兩個參數都應該是絕對路徑。透過 path.relative 會返回第二個參數相對於第一個參數的相對路徑。 如果兩個參數是一樣的，則會返回一個空字串。 如果其中一個參數為空字串，則執行的檔案目前的路徑則會取代該參數。 12path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb');// Returns: '../../impl/bbb' path.resolve([…paths]) 解析傳入的 ‘路徑’ 以及 ‘部分路徑’，組合並轉換成一個絕對路徑。 傳入的路徑參數會由右到左被執行。左邊的參數會被叫到右邊的參數前，直到組成一個絕對路徑。 如果所有的參數都已經被執行完，但還是無法產生一個絕對路徑，那就會使用目前的路徑。 最後的絕對路徑會經過格式化成正式的路徑，並且刪除多餘的 / 或 \，除非最後解析出來的路徑是根目錄。 若傳入的參數為空字串，會被忽略。 如果沒有傳入任何參數，會回傳目前的路徑。 123456789path.resolve('/foo/bar', './baz');// Returns: '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/');// Returns: '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// if the current working directory is /home/myself/node,// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif' 其實這樣講還是有點複雜，可以使用下面的方式來思考會比較簡單： 12path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')// Return '/tmp/subfile' $ cd foo/bar $ cd /tmp/file/ $ cd .. $ cd a/../subfile path.spe 會回傳你目前系統中預設的分隔符號。 參考資料 Path | Node.js v9.10.1 Path 模組 NodeJS - Path Tools - 這個 youtube 影片對 path 模組介紹的非常清楚]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
